<!DOCTYPE html>
<html>
  <head>
    <title>Far more than you've ever wanted to know about ADTs</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="css/style.css"/>
  </head>
  <body>
      <textarea id="source">
class: center, middle

# Far more than you've ever wanted to know about ADTs

Nicolas Rinaudo • [@NicolasRinaudo] • [Besedo]

---
class: center, middle

.center[![Our proud hero](img/gundam-hero.png)]

---

## Valid programs

![Facing south](img/valid-command-south.png)

---

## Valid programs

![Sending face north](img/valid-command-south-sending.png)

```haskell
face north
```

---

## Valid programs

![Facing north](img/valid-command-north.png)

```haskell
face north
```

---

## Valid programs

![Sending face west](img/valid-command-north-sending.png)

```haskell
face west
```

---

## Valid programs

![Facing west](img/valid-command-west.png)

```haskell
face west
```

---

## Valid programs

![Sending face south](img/valid-command-west-sending.png)

```haskell
face south
```

---

## Valid programs

![Facing south](img/valid-command-south.png)

```haskell
face south
```

---

## Valid programs

![Sending face east](img/valid-command-south-sending.png)

```haskell
face east
```

---

## Valid programs

![Facing east](img/valid-command-east.png)

```haskell
face east
```

---

## Valid programs

![Sending start](img/valid-command-east-sending.png)

```haskell
start
```

---

## Valid programs

![Started](img/valid-command-start.png)

```haskell
start
```

---

## Valid programs

![Sending stop](img/valid-command-start-sending.png)

```haskell
stop
```

---

## Valid programs

![Stopped](img/valid-command-stop.png)

```haskell
stop
```

---

## Invalid programs

![Sending triple_backflip](img/valid-command-stop-sending.png)

```haskell
triple_backflip
```

---

## Invalid programs

![Confused](img/valid-command-wat.png)

```haskell
triple_backflip
```

---

## Invalid programs

![Kaboom](img/valid-command-boom.png)

```haskell
triple_backflip
```

---

## Invalid programs

![Sending face -35](img/valid-command-stop-sending.png)

```haskell
face -35
```
---

## Invalid programs

![Rejected](img/valid-command-rejected.png)

```haskell
face -35
```

---

## Invalid programs

![Rejected](img/valid-command-rejected-2.png)

```haskell
face -35
```

---
class: center, middle

# Representing `Direction`

---

## Magic values

```scala
object Direction {
}
```

---

## Magic values

.diff-add[
```scala
object Direction {
* `val North: Int = 1`
}
```
]

---

## Magic values

.diff-add[
```scala
object Direction {
  val North: Int = 1
* `val East:  Int = 2`
}
```
]

---

## Magic values

.diff-add[
```scala
object Direction {
  val North: Int = 1
  val East:  Int = 2
* `val South: Int = 3`
}
```
]

---

## Magic values

.diff-add[
```scala
object Direction {
  val North: Int = 1
  val East:  Int = 2
  val South: Int = 3
* `val West:  Int = 4`
}
```
]

---

## Magic values

```scala
object Direction {
  val North: Int = 1
  val East:  Int = 2
  val South: Int = 3
  val West:  Int = 4
}
```

---

## Magic values

```scala
def label(d: Int) =
  d match {
    case Direction.North ⇒ "north"
    case Direction.East  ⇒ "east"
    case Direction.South ⇒ "south"
    case Direction.West  ⇒ "west"
  }
```

---

## Magic values

```scala
def label(`d: Int`) =
  d match {
    case Direction.North ⇒ "north"
    case Direction.East  ⇒ "east"
    case Direction.South ⇒ "south"
    case Direction.West  ⇒ "west"
  }
```

---

## Magic values

```scala
def label(d: Int) =
  `d match` {
    case Direction.North ⇒ "north"
    case Direction.East  ⇒ "east"
    case Direction.South ⇒ "south"
    case Direction.West  ⇒ "west"
  }
```

---

## Magic values

```scala
def label(d: Int) =
  d match {
    case `Direction.North` ⇒ "north"
    case `Direction.East`  ⇒ "east"
    case `Direction.South` ⇒ "south"
    case `Direction.West`  ⇒ "west"
  }
```

---

## Magic values

```scala
def label(d: Int) =
  d match {
    case Direction.North ⇒ `"north"`
    case Direction.East  ⇒ `"east"`
    case Direction.South ⇒ `"south"`
    case Direction.West  ⇒ `"west"`
  }
```

---

## Magic values

![Sending face -35](img/valid-command-east-sending.png)

```scala
label(-35)
```

---

## Magic values

![Kaboom](img/valid-command-boom.png)

```scala
label(-35)
// scala.MatchError: -35 (of class java.lang.Integer)
//   at .label(<console>:3)
//   ... 42 elided
```

---

## Type aliases

```scala
object Direction {
  val North: Int = 1
  val East:  Int = 2
  val South: Int = 3
  val West:  Int = 4
}
```

---

## Type aliases

.diff-add[
```scala
*&#x200B;`type Direction = Int`
*
object Direction {
  val North: Int = 1
  val East:  Int = 2
  val South: Int = 3
  val West:  Int = 4
}
```
]

---

## Type aliases

.diff-rm[
```scala
type Direction = Int

object Direction {
* val North: `Int` = 1
* val East:  `Int` = 2
* val South: `Int` = 3
* val West:  `Int` = 4
}
```
]
---

## Type aliases

.diff-add[
```scala
type Direction = Int

object Direction {
* val North: `Direction` = 1
* val East:  `Direction` = 2
* val South: `Direction` = 3
* val West:  `Direction` = 4
}
```
]

---

## Type aliases

```scala
type Direction = Int

object Direction {
  val North: Direction = 1
  val East:  Direction = 2
  val South: Direction = 3
  val West:  Direction = 4
}
```

---

## Type aliases

.diff-rm[
```scala
*def label(d: `Int`) =
  d match {
    case Direction.North ⇒ "north"
    case Direction.East  ⇒ "east"
    case Direction.South ⇒ "south"
    case Direction.West  ⇒ "west"
  }
```
]

---

## Type aliases

.diff-add[
```scala
*def label(d: `Direction`) =
  d match {
    case Direction.North ⇒ "north"
    case Direction.East  ⇒ "east"
    case Direction.South ⇒ "south"
    case Direction.West  ⇒ "west"
  }
```
]

---

## Type aliases

```scala
def label(d: Direction) =
  d match {
    case Direction.North ⇒ "north"
    case Direction.East  ⇒ "east"
    case Direction.South ⇒ "south"
    case Direction.West  ⇒ "west"
  }
```

---

## Type aliases

![Sending face -35](img/valid-command-east-sending.png)

```scala
label(-35)
```

---

## Type aliases

![Kaboom](img/valid-command-boom.png)

```scala
label(-35)
// scala.MatchError: -35 (of class java.lang.Integer)
//   at .label(<console>:3)
//   ... 42 elided
```

---

## Scala's `Enumeration`

```scala
object Direction {
}
```

---

## Scala's `Enumeration`

.diff-add[
```scala
*object Direction `extends Enumeration` {
}
```
]

---

## Scala's `Enumeration`

.diff-add[
```scala
object Direction extends Enumeration {
* `val North = Value`
}
```
]

---

## Scala's `Enumeration`

.diff-add[
```scala
object Direction extends Enumeration {
* val North`, East` = Value
}
```
]

---

## Scala's `Enumeration`

.diff-add[
```scala
object Direction extends Enumeration {
* val North, East`, South` = Value
}
```
]

---

## Scala's `Enumeration`

.diff-add[
```scala
object Direction extends Enumeration {
* val North, East, South`, West` = Value
}
```
]

---

## Scala's `Enumeration`

```scala
object Direction extends Enumeration {
  val North, East, South, West = Value
}
```

---

## Scala's `Enumeration`

.diff-rm[
```scala
*def label(d: `Direction`) =
  d match {
    case Direction.North ⇒ "north"
    case Direction.East  ⇒ "east"
    case Direction.South ⇒ "south"
    case Direction.West  ⇒ "west"
  }
```
]

---

## Scala's `Enumeration`

.diff-add[
```scala
*def label(d: `Direction.Value`) =
  d match {
    case Direction.North ⇒ "north"
    case Direction.East  ⇒ "east"
    case Direction.South ⇒ "south"
    case Direction.West  ⇒ "west"
  }
```
]

---

## Scala's `Enumeration`

```scala
def label(d: Direction.Value) =
  d match {
    case Direction.North ⇒ "north"
    case Direction.East  ⇒ "east"
    case Direction.South ⇒ "south"
    case Direction.West  ⇒ "west"
  }
```

---

## Scala's `Enumeration`

![Sending face -35](img/valid-command-east-sending.png)

```scala
label(-35)
```

---

## Scala's `Enumeration`

![Rejected](img/valid-command-rejected.png)

```scala
label(-35)
//        label(-35)
//              ^
// On line 2: error: type mismatch;
//         found   : Int(-35)
//         required: Direction.Value
```

---

## Scala's `Enumeration`

```scala
def label(d: Direction.Value) =
  d match {
    case Direction.North ⇒ "north"
    case Direction.East  ⇒ "east"
    case Direction.South ⇒ "south"
    case Direction.West  ⇒ "west"
  }
```

---

## Scala's `Enumeration`

.diff-rm[
```scala
def label(d: Direction.Value) =
  d match {
    case Direction.North ⇒ "north"
    case Direction.East  ⇒ "east"
    case Direction.South ⇒ "south"
*   `case Direction.West  ⇒ "west"`
  }
```
]

---

## Scala's `Enumeration`

.diff-add[
```scala
def label(d: Direction.Value) =
  d match {
    case Direction.North ⇒ "north"
    case Direction.East  ⇒ "east"
    case Direction.South ⇒ "south"
*&#x200B; `// case Direction.West  ⇒ "west"`
  }
```
]

---

## Scala's `Enumeration`

```scala
def label(d: Direction.Value) =
  d match {
    case Direction.North ⇒ "north"
    case Direction.East  ⇒ "east"
    case Direction.South ⇒ "south"
 // case Direction.West  ⇒ "west"
  }
```

---

## Scala's `Enumeration`

![Sending face west](img/valid-command-east-sending.png)

```scala
label(Direction.West)
```

---

## Scala's `Enumeration`

![Kaboom](img/valid-command-boom.png)

```scala
label(Direction.West)
// scala.MatchError: West (of class scala.Enumeration$Val)
//   at .label(<console>:3)
//   ... 42 elided
```

---

## Hand-written enumeration

```scala
trait Direction
```

---

## Hand-written enumeration

.diff-add[
```scala
trait Direction
*
&#x200B;`object Direction {`
&#x200B;`}`
```
]

---

## Hand-written enumeration

.diff-add[
```scala
trait Direction

object Direction {
* `case object North extends Direction`
}
```
]

---

## Hand-written enumeration

```scala
trait Direction

object Direction {
  case object North `extends Direction`
}
```

---

## Hand-written enumeration

.diff-add[
```scala
trait Direction

object Direction {
  case object North extends Direction
* `case object East  extends Direction`
}
```
]

---

## Hand-written enumeration

.diff-add[
```scala
trait Direction

object Direction {
  case object North extends Direction
  case object East  extends Direction
* `case object South extends Direction`
}
```
]

---

## Hand-written enumeration

.diff-add[
```scala
trait Direction

object Direction {
  case object North extends Direction
  case object East  extends Direction
  case object South extends Direction
* `case object West  extends Direction`
}
```
]

---

## Hand-written enumeration

```scala
trait Direction

object Direction {
  case object North extends Direction
  case object East  extends Direction
  case object South extends Direction
  case object West  extends Direction
}
```

---

## Hand-written enumeration

```scala
def label(d: Direction.Value) =
  d match {
    case Direction.North ⇒ "north"
    case Direction.East  ⇒ "east"
    case Direction.South ⇒ "south"
 // case Direction.West  ⇒ "west"
}
```

---

## Hand-written enumeration

.diff-rm[
```scala
*def label(d: `Direction.Value`) =
  d match {
    case Direction.North ⇒ "north"
    case Direction.East  ⇒ "east"
    case Direction.South ⇒ "south"
 // case Direction.West  ⇒ "west"
}
```
]

---

## Hand-written enumeration

.diff-add[
```scala
*def label(d: `Direction`) =
  d match {
    case Direction.North ⇒ "north"
    case Direction.East  ⇒ "east"
    case Direction.South ⇒ "south"
 // case Direction.West  ⇒ "west"
}
```
]

---

## Hand-written enumeration

```scala
def label(d: Direction) =
  d match {
    case Direction.North ⇒ "north"
    case Direction.East  ⇒ "east"
    case Direction.South ⇒ "south"
 // case Direction.West  ⇒ "west"
}
```

---

## Hand-written enumeration

![Sending face west](img/valid-command-east-sending.png)

```scala
label(Direction.West)
```

---

## Hand-written enumeration

![Kaboom](img/valid-command-boom.png)

```scala
label(Direction.West)
// scala.MatchError: West (of class Direction$West$)
//   at .label(<console>:3)
//   ... 42 elided
```

---

## Hand-written enumeration

```scala
trait Direction

object Direction {
  case object North extends Direction
  case object East  extends Direction
  case object South extends Direction
  case object West  extends Direction
}
```

---

## Hand-written enumeration

.diff-add[
```scala
&#x200B;`sealed` trait Direction

object Direction {
  case object North extends Direction
  case object East  extends Direction
  case object South extends Direction
  case object West  extends Direction
}
```
]

---

## Hand-written enumeration

```scala
sealed trait Direction

object Direction {
  case object North extends Direction
  case object East  extends Direction
  case object South extends Direction
  case object West  extends Direction
}
```

---

## Hand-written enumeration

```scala
def label(d: Direction) =
  d match {
    case Direction.North ⇒ "north"
    case Direction.East  ⇒ "east"
    case Direction.South ⇒ "south"
 // case Direction.West  ⇒ "west"
}
```

---

## Hand-written enumeration

```scala
def label(d: Direction) =
  d match {
    case Direction.North ⇒ "north"
    case Direction.East  ⇒ "east"
    case Direction.South ⇒ "south"
 // case Direction.West  ⇒ "west"
}
//          d match {
//          ^
// On line 3: warning: match may not be exhaustive.
//        It would fail on the following input: West
// error: No warnings can be incurred under -Werror.
```

---

## Key takeaways

--

Enumerations&#x200B;:

--

* make nonsensical values impossible to represent.

--

* guarantee that our code handles all necessary cases.

--

* provided you're not using `scala.Enumeration` though...

---
class: center, middle

# Representing `Command`

---

## Case class

```scala
case class Command(
  order: String,
  dir  : Option[Direction]
)
```

```scala
val cmd = Command(
  "face",
  Some(Direction.North)
)
```

---

## Case class

```scala
&#x200B;`case class Command`(
  order: String,
  dir  : Option[Direction]
)
```

```scala
val cmd = `Command`(
  "face",
  Some(Direction.North)
)
```

---

## Case class

```scala
case class Command(
  `order: String`,
  dir  : Option[Direction]
)
```

```scala
val cmd = Command(
  `"face"`,
  Some(Direction.North)
)
```

---

## Case class

```scala
case class Command(
  order: String,
  `dir  : Option[Direction]`
)
```

```scala
val cmd = Command(
  "face",
  `Some(Direction.North)`
)
```

---

## Case class

![Triple backflip](img/valid-command-east-sending.png)

```scala
Command(
  "triple backflip",
  Some(Direction.South)
)
```

---

## Case class

![Triple backflip](img/valid-command-east-sending.png)

```scala
Command(
  `"triple backflip"`,
  Some(Direction.South)
)
```

---

## Case class

![Kaboom](img/valid-command-boom.png)

```scala
Command(
  "triple backflip",
  Some(Direction.South)
)
```

---

## `Order` as enumeration

```scala
sealed trait Order

object Order {
  case object Face  extends Order
  case object Start extends Order
  case object Stop  extends Order
}
```

---

## `Order` as enumeration

```scala
&#x200B;`sealed trait Order`

object Order {
  case object Face  extends Order
  case object Start extends Order
  case object Stop  extends Order
}
```

---

## `Order` as enumeration

```scala
sealed trait Order

object Order {
  case object `Face  extends Order`
  case object Start extends Order
  case object Stop  extends Order
}
```

---

## `Order` as enumeration

```scala
sealed trait Order

object Order {
  case object Face  extends Order
  case object `Start extends Order`
  case object Stop  extends Order
}
```

---

## `Order` as enumeration

```scala
sealed trait Order

object Order {
  case object Face  extends Order
  case object Start extends Order
  case object `Stop  extends Order`
}
```

---

## `Order` as enumeration

```scala
case class Command(
  order: String,
  dir  : Option[Direction]
)
```

```scala
val cmd = Command(
  "face",
  Some(Direction.North)
)
```

---

## `Order` as enumeration

.diff-rm[
```scala
case class Command(
* order: `String`,
  dir  : Option[Direction]
)
```

```scala
val cmd = Command(
* `"face"`,
  Some(Direction.North)
)
```
]

---

## `Order` as enumeration

.diff-add[
```scala
case class Command(
* order: `Order`,
  dir  : Option[Direction]
)
```

```scala
val cmd = Command(
* `Order.Face`,
  Some(Direction.North)
)
```
]

---

## `Order` as enumeration

```scala
case class Command(
  order: Order,
  dir  : Option[Direction]
)
```

```scala
val cmd = Command(
  Order.Face,
  Some(Direction.North)
)
```

---

## `Order` as enumeration

![Sending triple backflip](img/valid-command-east-sending.png)

```scala
Command(
  "triple backflip",
  Some(Direction.South)
)
```

---

## `Order` as enumeration

![Rejected](img/valid-command-rejected.png)

```scala
Command(
  "triple backflip",
  Some(Direction.South)
)
//          "triple backflip",
//          ^
// On line 3: error: type mismatch;
//         found   : String("triple backflip")
//         required: Order
```

---

## `Order` as enumeration

![Sending start south](img/valid-command-east-sending.png)

```scala
Command(
  Order.Start,
  Some(Direction.South)
)
```

---

## `Order` as enumeration

![Sending start south](img/valid-command-east-sending.png)

```scala
Command(
  Order.`Start`,
  Some(Direction.`South`)
)
```

---

## `Order` as enumeration

![Kaboom](img/valid-command-boom.png)

```scala
Command(
  Order.Start,
  Some(Direction.South)
)
```

---

## `Order` as "enumeration"

```scala
sealed trait Order

object Order {
  case object Face  extends Order
  case object Start extends Order
  case object Stop  extends Order
}
```

---

## `Order` as "enumeration"

.diff-rm[
```scala
sealed trait Order

object Order {
* case `object Face`  extends Order
  case object Start extends Order
  case object Stop  extends Order
}
```
]

---

## `Order` as "enumeration"

.diff-add[
```scala
sealed trait Order

object Order {
* case `class  Face(dir: Direction)` extends Order
* case object Start `               `extends Order
* case object Stop  `               `extends Order
}
```
]

---

## `Order` as "enumeration"

```scala
sealed trait Order

object Order {
  case class  Face(dir: Direction) extends Order
  case object Start                extends Order
  case object Stop                 extends Order
}
```

---

## `Order` as "enumeration"

.diff-rm[
```scala
*sealed trait `Order`

*object `Order` {
* case class  Face(dir: Direction) extends `Order`
* case object Start                extends `Order`
* case object Stop                 extends `Order`
}
```
]

---

## `Command` as "enumeration"

.diff-add[
```scala
*sealed trait `Command`

*object `Command` {
* case class  Face(dir: Direction) extends `Command`
* case object Start                extends `Command`
* case object Stop                 extends `Command`
}
```
]

---

## `Command` as "enumeration"

```scala
sealed trait Command

object Command {
  case class  Face(dir: Direction) extends Command
  case object Start                extends Command
  case object Stop                 extends Command
}
```

---

## `Command` as "enumeration"

![Sending start south](img/valid-command-east-sending.png)

```scala
Command(
  Order.Start,
  Some(Direction.South)
)
```

---

## `Command` as "enumeration"

![Rejected](img/valid-command-rejected.png)

```scala
Command(
  Order.Start,
  Some(Direction.South)
)
//        Command(
//               ^
// On line 2: error: Command.type does not take parameters
```

---

## `Command` as "enumeration"

![Sending](img/valid-command-east-sending.png)

```scala
Command.Start
```

---

## `Command` as "enumeration"

![Sending](img/valid-command-start.png)

```scala
Command.Start
// res9: Command.Start.type = Start
```

---

## Key takeaways

--

* Enumerations are everywhere.

--

* Enumerations are not enough.

--

* Something "like an enumeration" might be, however.

---
class: center, middle

# Composing commands

---

## Script

![Waiting command](img/valid-command-south.png)

```haskell
start
```

---

## Script

![Waiting command](img/valid-command-south.png)

```haskell
face east
start
stop
```

---

## Script

![Sending script](img/valid-command-south-sending.png)

```haskell
face east
start
stop
```

---

## Script

![Starting](img/valid-command-east.png)

```haskell
&#x200B;`face east`
start
stop
```

---

## Script

![Continue advancing](img/valid-command-start.png)

```haskell
face east
&#x200B;`start`
stop
```

---

## Script

![Stopping](img/valid-command-stop.png)

```haskell
face east
start
&#x200B;`stop`
```

---

## Chaining commands

```scala
sealed trait Command

object Command {
  case class  Face(dir: Direction) extends Command
  case object Start                extends Command
  case object Stop                 extends Command
}
```

---

## Chaining commands

.diff-add[
```scala
sealed trait Command

object Command {
  case class  Face(dir: Direction) extends Command
  case object Start                extends Command
  case object Stop                 extends Command
*
* `case class Chain(`
* `) extends Command`
}
```
]

---

## Chaining commands

.diff-add[
```scala
sealed trait Command

object Command {
  case class  Face(dir: Direction) extends Command
  case object Start                extends Command
  case object Stop                 extends Command

  case class Chain(
*   `cmd1: Command`
  ) extends Command
}
```
]

---

## Chaining commands

.diff-add[
```scala
sealed trait Command

object Command {
  case class  Face(dir: Direction) extends Command
  case object Start                extends Command
  case object Stop                 extends Command

  case class Chain(
*   cmd1: Command`,`
*   `cmd2: Command`
  ) extends Command
}
```
]

---

## Chaining commands

```scala
sealed trait Command

object Command {
  case class  Face(dir: Direction) extends Command
  case object Start                extends Command
  case object Stop                 extends Command

  case class Chain(
    cmd1: Command,
    cmd2: Command
  ) extends Command
}
```

---

## Chaining commands

```scala
Command.Chain(
  Command.Chain(
    Command.Chain(
      Command.Face(Direction.East),
      Command.Chain(
        Command.Start,
        Command.Stop
      )
    ),
    Command.Face(Direction.West)
  ),
  Command.Chain(
    Command.Start,
    Command.Stop
  )
)
```

---

## Chaining commands

```scala
Command.Chain(
  Command.Chain(
    Command.Chain(
      Command.`Face`(Direction.`East`),
      Command.Chain(
        Command.Start,
        Command.Stop
      )
    ),
    Command.Face(Direction.West)
  ),
  Command.Chain(
    Command.Start,
    Command.Stop
  )
)
```

---

## Chaining commands

```scala
Command.Chain(
  Command.Chain(
    Command.Chain(
      Command.Face(Direction.East),
      Command.Chain(
        Command.`Start`,
        Command.Stop
      )
    ),
    Command.Face(Direction.West)
  ),
  Command.Chain(
    Command.Start,
    Command.Stop
  )
)
```

---

## Chaining commands

```scala
Command.Chain(
  Command.Chain(
    Command.Chain(
      Command.Face(Direction.East),
      Command.Chain(
        Command.Start,
        Command.`Stop`
      )
    ),
    Command.Face(Direction.West)
  ),
  Command.Chain(
    Command.Start,
    Command.Stop
  )
)
```

---

## Chaining commands

```scala
Command.Chain(
  Command.Chain(
    Command.Chain(
      Command.Face(Direction.East),
      Command.Chain(
        Command.Start,
        Command.Stop
      )
    ),
    Command.`Face`(Direction.`West`)
  ),
  Command.Chain(
    Command.Start,
    Command.Stop
  )
)
```
---

## Chaining commands

```scala
Command.Chain(
  Command.Chain(
    Command.Chain(
      Command.Face(Direction.East),
      Command.Chain(
        Command.Start,
        Command.Stop
      )
    ),
    Command.Face(Direction.West)
  ),
  Command.Chain(
    Command.`Start`,
    Command.Stop
  )
)
```

---

## Chaining commands

```scala
Command.Chain(
  Command.Chain(
    Command.Chain(
      Command.Face(Direction.East),
      Command.Chain(
        Command.Start,
        Command.Stop
      )
    ),
    Command.Face(Direction.West)
  ),
  Command.Chain(
    Command.Start,
    Command.`Stop`
  )
)
```

---

## DSL

```scala
implicit class Compose(cmd1: Command) {
  def ~>(cmd2: Command): Command =
    Command.Chain(cmd1, cmd2)
}
```

```scala
val startStop: Command =
  Command.Start ~> Command.Stop
```

---

## DSL

```scala
implicit class Compose(`cmd1: Command`) {
  def ~>(cmd2: Command): Command =
    Command.Chain(cmd1, cmd2)
}
```

```scala
val startStop: Command =
  `Command.Start` ~> Command.Stop
```

---

## DSL

```scala
implicit class Compose(cmd1: Command) {
  def `~>`(cmd2: Command): Command =
    Command.Chain(cmd1, cmd2)
}
```

```scala
val startStop: Command =
  Command.Start `~>` Command.Stop
```

---

## DSL

```scala
implicit class Compose(cmd1: Command) {
  def ~>(`cmd2: Command`): Command =
    Command.Chain(cmd1, cmd2)
}
```

```scala
val startStop: Command =
  Command.Start ~> Command.`Stop`
```

---

## DSL

```scala
implicit class Compose(cmd1: Command) {
  def ~>(cmd2: Command): Command =
    Command.`Chain(cmd1, cmd2)`
}
```

```scala
val `startStop`: Command =
  Command.Start ~> Command.Stop
```

---

## DSL

```scala
val start                = Command.Start
val stop                 = Command.Stop
def face(dir: Direction) = Command.Face(dir)
```

---

## DSL

```scala
&#x200B;`val start                = Command.Start`
val stop                 = Command.Stop
def face(dir: Direction) = Command.Face(dir)
```

---

## DSL

```scala
val start                = Command.Start
&#x200B;`val stop                 = Command.Stop`
def face(dir: Direction) = Command.Face(dir)
```

---

## DSL

```scala
val start                = Command.Start
val stop                 = Command.Stop
&#x200B;`def face(dir: Direction) = Command.Face(dir)`
```

---

## DSL

```scala
val north = Direction.North
val east  = Direction.East
val south = Direction.South
val west  = Direction.West
```

---

## DSL

```scala
&#x200B;`val north = Direction.North`
val east  = Direction.East
val south = Direction.South
val west  = Direction.West
```

---

## DSL

```scala
val north = Direction.North
&#x200B;`val east  = Direction.East`
val south = Direction.South
val west  = Direction.West
```

---

## DSL

```scala
val north = Direction.North
val east  = Direction.East
&#x200B;`val south = Direction.South`
val west  = Direction.West
```

---

## DSL

```scala
val north = Direction.North
val east  = Direction.East
val south = Direction.South
&#x200B;`val west  = Direction.West`
```

---

## Compound commands

```scala
def move(d: Direction) =
  face(d) ~> start ~> stop
```

---

## Compound commands

```scala
def move(`d: Direction`) =
  face(d) ~> start ~> stop
```

---

## Compound commands

```scala
def move(d: Direction) =
  `face(d)` ~> start ~> stop
```

---

## Compound commands

```scala
def move(d: Direction) =
  face(d) ~> `start` ~> stop
```

---

## Compound commands

```scala
def move(d: Direction) =
  face(d) ~> start ~> `stop`
```

---

## Compound commands

![Sending script](img/valid-command-south.png)

```scala
 move(east) ~> move(west)
```

---

## Compound commands

![Sending script](img/valid-command-south-sending.png)

```scala
 move(east) ~> move(west)
```

---

## Compound commands

![Sending script](img/valid-command-east.png)

```scala
 `move(east)` ~> move(west)
```

---

## Compound commands

![Sending script](img/valid-command-start.png)

```scala
 `move(east)` ~> move(west)
```

---

## Compound commands

![Sending script](img/valid-command-stop.png)

```scala
 `move(east)` ~> move(west)
```

---

## Compound commands

![Sending script](img/valid-command-west.png)

```scala
 move(east) ~> `move(west)`
```

---

## Compound commands

![Sending script](img/valid-command-start-4.png)

```scala
 move(east) ~> `move(west)`
```

---

## Compound commands

![Sending script](img/valid-command-stop-3.png)

```scala
 move(east) ~> `move(west)`
```

---

## Key takeaways

--

We've completed our data structure by using:

--

* records (`Chain`, `Face`).

--

* enumerated types (`Command`, `Direction`).

--

* recursive types (`Command` is expressed in terms of itself).

---
class: center, middle

# Algebraic Data Types

---

## Sum types

```scala
Command = Face
        ⋁ Start
        ⋁ Stop
        ⋁ Chain
```

---

## Sum types

```scala
Command = `Face`
        ⋁ Start
        ⋁ Stop
        ⋁ Chain
```

---

## Sum types

```scala
Command = Face
        ⋁ `Start`
        ⋁ Stop
        ⋁ Chain
```

---

## Sum types

```scala
Command = Face
        ⋁ Start
        ⋁ `Stop`
        ⋁ Chain
```

---

## Sum types

```scala
Command = Face
        ⋁ Start
        ⋁ Stop
        ⋁ `Chain`
```

---

## Sum types

```scala
Command = Face
        ⋁ Start
        ⋁ Stop
        ⋁ Chain
```

> A sum type is a discriminated union of values, and can be thought of as an `OR` on types.

---

## Sum types

```scala
Command = Face
        `⋁` Start
        `⋁` Stop
        `⋁` Chain
```

> A sum type is a discriminated union of values, and can be thought of as an .highlight[`OR`] on types.

---

## Sum types

```scala
Command = Face
        ⋁ Start
        ⋁ Stop
        ⋁ Chain
```

> A sum type is a .highlight[discriminated] union of values, and can be thought of as an `OR` on types.

---

## Union types

```c
union int_or_string {
  int   as_int;
  char* as_string;
};
```

---

## Union types

```c
union `int_or_string` {
  int   as_int;
  char* as_string;
};
```

---

## Union types

```c
union int_or_string {
  `int   as_int;`
  char* as_string;
};
```

---

## Union types

```c
union int_or_string {
  int   as_int;
  `char* as_string;`
};
```

---

## Union types

```c
#include<stdio.h>

void print_union(union int_or_string e) {
    ???
}
```

---

## Union types

```c
#include<stdio.h>

void print_union(union int_or_string e) {
    `???`
}
```

---

## Manually discriminated union types

```c
enum typetag {
    int_tag,
    string_tag
};
```

---

## Manually discriminated union types

```c
enum `typetag` {
    int_tag,
    string_tag
};
```

---

## Manually discriminated union types

```c
enum typetag {
    `int_tag`,
    string_tag
};
```

---

## Manually discriminated union types

```c
enum typetag {
    int_tag,
    `string_tag`
};
```

---


## Manually discriminated union types

```c
union int_or_string {
    int   as_int;
    char* as_string;
};
```

---

## Manually discriminated union types

.diff-add[
```c
union int_or_string {
*   `enum typetag discriminator;`
*
    int   as_int;
    char* as_string;
};
```
]

---

## Manually discriminated union types

.diff-rm[
```c
*&#x200B;`union` int_or_string {
    enum typetag discriminator;

    int   as_int;
    char* as_string;
};
```
]

---

## Manually discriminated union types

.diff-add[
```c
*&#x200B;`struct` int_or_string {
    enum typetag discriminator;

    int   as_int;
    char* as_string;
};
```
]

---

## Manually discriminated union types

.diff-rm[
```c
struct int_or_string {
    enum typetag discriminator;

*   `int   as_int;`
*   `char* as_string;`
};
```
]

---

## Manually discriminated union types

.diff-add[
```c
struct int_or_string {
    enum typetag discriminator;

*   `union {`
*   `    int   as_int;`
*   `    char* as_string;`
*   `} value;`
};
```
]

---

## Manually discriminated union types

```c
struct int_or_string {
    enum typetag discriminator;

    union {
        int   as_int;
        char* as_string;
    } value;
};
```

---

## Manually discriminated union types

```c
struct int_or_string {
    enum typetag discriminator;

*   union {
*       int   as_int;
*       char* as_string;
*   } value;
};
```

---

## Manually discriminated union types

```c
struct int_or_string {
*   enum typetag discriminator;

    union {
        int   as_int;
        char* as_string;
    } value;
};
```

---

## Manually discriminated union types

```c
#include<stdio.h>

void print_union(union int_or_string e) {
    ???
}
```

---

## Manually discriminated union types

.diff-rm[
```c
#include<stdio.h>

*void print_union(`union` int_or_string e) {
    ???
}
```
]

---

## Manually discriminated union types

.diff-add[
```c
#include<stdio.h>

*void print_union(`struct` int_or_string e) {
    ???
}
```
]

---

## Manually discriminated union types

.diff-rm[
```c
#include<stdio.h>

void print_union(struct int_or_string e) {
*   `???`
}
```
]

---

## Manually discriminated union types

.diff-add[
```c
#include<stdio.h>

void print_union(struct int_or_string e) {
*   `if(e.discriminator == int_tag) {`
*       `printf("int: %i", e.value.as_int);`
*   `}`
*   `else {`
*       `printf("string: %s", e.value.as_string);`
*   `}`
}
```
]

---

## Manually discriminated union types

```c
#include<stdio.h>

void print_union(struct int_or_string e) {
    if(`e.discriminator == int_tag`) {
        printf("int: %i", e.value.as_int);
    }
    else {
        printf("string: %s", e.value.as_string);
    }
}
```

---

## Manually discriminated union types

```c
#include<stdio.h>

void print_union(struct int_or_string e) {
    if(e.discriminator == int_tag) {
        printf("int: %i", `e.value.as_int`);
    }
    else {
        printf("string: %s", e.value.as_string);
    }
}
```

---

## Manually discriminated union types

```c
#include<stdio.h>

void print_union(struct int_or_string e) {
    if(e.discriminator == int_tag) {
        printf("int: %i", e.value.as_int);
    }
    else {
        printf("string: %s", `e.value.as_string`);
    }
}
```

---

## Sum types

```scala
Command = Face
        ⋁ Start
        ⋁ Stop
        ⋁ Chain
```

> A sum type is a .highlight[discriminated] union of values, and can be thought of as an `OR` on types.

---

## Sum types

> An ADT is a sum type [...]

---

## Product types

```scala
Command = Face
        ⋁ Start
        ⋁ Stop
        ⋁ Chain
```

---

## Product types

.diff-rm[
```scala
Command = Face
        ⋁ Start
        ⋁ Stop
*       ⋁ `Chain`
```
]

---

## Product types

.diff-add[
```scala
Command = Face
        ⋁ Start
        ⋁ Stop
*       ⋁ `Command ⋀ Command`
```
]

---

## Product types

```scala
Command = Face
        ⋁ Start
        ⋁ Stop
        ⋁ `Command` ⋀ Command
```

---

## Product types

```scala
Command = Face
        ⋁ Start
        ⋁ Stop
        ⋁ Command ⋀ `Command`
```

---

## Product types

```scala
Command = Face
        ⋁ Start
        ⋁ Stop
        ⋁ Command ⋀ Command
```

> A product type is an aggregation of values, and can be thought of as an `AND` on types.

---

## Product types

```scala
Command = Face
        ⋁ Start
        ⋁ Stop
        ⋁ Command `⋀` Command
```

> A product type is an aggregation of values, and can be thought of as an .highlight[`AND`] on types.

---

## Product types


> An ADT is a sum type of product types [...]

---

## Algebraic Data Types

```scala
Command = Face
        ⋁ Start
        ⋁ Stop
        ⋁ Command ⋀ Command
```

---

## Algebraic Data Types

```scala
&#x200B;`Command` = Face
        ⋁ Start
        ⋁ Stop
        ⋁ Command ⋀ Command
```

---

## Algebraic Data Types

```scala
Command = Face
        ⋁ Start
        ⋁ Stop
        ⋁ `Command` ⋀ `Command`
```

---

## Algebraic Data Types

> An ADT is a potentially recursive sum type of product types.

---

## Key takeaways

--

Algebraic Data Types are:

--

* sum types.

--

* product types.

--

* potentially recursive.


---
class: center, middle

# Safe command composition

---

## Illegal state transition

![Start ](img/valid-command-east-sending.png)

```scala
 start ~> start
```

---

## Illegal state transition

![Start ](img/valid-command-start.png)

```scala
 `start` ~> start
```

---

## Illegal state transition

![Start ](img/valid-command-start-wat.png)

```scala
 start ~> `start`
```

---

## Illegal state transition

![Start ](img/valid-command-boom.png)

```scala
 start ~> start
```

---

## Illegal state transition

![Start](img/valid-command-start-sending.png)

```scala
 stop ~> stop
```

---

## Illegal state transition

![Start](img/valid-command-stop.png)

```scala
 `stop` ~> stop
```

---

## Illegal state transition

![Start ](img/valid-command-wat.png)

```scala
 stop ~> `stop`
```

---

## Illegal state transition

![Start](img/valid-command-boom.png)

```scala
 stop ~> stop
```

---

## Illegal state transition

![Start](img/valid-command-east-sending.png)

```scala
 start ~> face(north)
```

---

## Illegal state transition

![Start](img/valid-command-start.png)

```scala
 `start` ~> face(north)
```

---

## Illegal state transition

![Start](img/valid-command-start-wtf.png)

```scala
 start ~> `face(north)`
```

---

## Illegal state transition

![Start](img/valid-command-boom.png)
.foreground[![Big badaboom](img/large-explosion.png)]

```scala
 start ~> face(north)
```

---

## Tracking state

```scala
final abstract class Idle
final abstract class Moving
```

---

## Tracking state

```scala
&#x200B;`final abstract class Idle`
final abstract class Moving
```

---

## Tracking state

```scala
final abstract class Idle
&#x200B;`final abstract class Moving`
```

---

## Tracking state

```scala
sealed trait Command

object Command {
  case class  Face(dir: Direction) extends Command
  case object Start                extends Command
  case object Stop                 extends Command

  case class Chain(
    cmd1: Command,
    cmd2: Command
  ) extends Command
}
```

---

## Tracking state

.diff-add[
```scala
*sealed trait Command`[Before, After]`

object Command {
  case class  Face(dir: Direction) extends Command
  case object Start                extends Command
  case object Stop                 extends Command

  case class Chain(
    cmd1: Command,
    cmd2: Command
  ) extends Command
}
```
]

---

## Tracking state

```scala
sealed trait Command[Before, After]

object Command {
  case class  `Face`(dir: Direction) extends Command
  case object Start                extends Command
  case object Stop                 extends Command

  case class Chain(
    cmd1: Command,
    cmd2: Command
  ) extends Command
}
```

---

## Tracking state

.diff-add[
```scala
sealed trait Command[Before, After]

object Command {
* case class  Face(dir: Direction) extends Command`[Idle, Idle]`
  case object Start                extends Command
  case object Stop                 extends Command

  case class Chain(
    cmd1: Command,
    cmd2: Command
  ) extends Command
}
```
]

---

## Tracking state

```scala
sealed trait Command[Before, After]

object Command {
  case class  Face(dir: Direction) extends Command[Idle, Idle]
  case object `Start`                extends Command
  case object Stop                 extends Command

  case class Chain(
    cmd1: Command,
    cmd2: Command
  ) extends Command
}
```

---

## Tracking state

.diff-add[
```scala
sealed trait Command[Before, After]

object Command {
  case class  Face(dir: Direction) extends Command[Idle, Idle]
* case object Start                extends Command`[Idle, Moving]`
  case object Stop                 extends Command

  case class Chain(
    cmd1: Command,
    cmd2: Command
  ) extends Command
}
```
]


---

## Tracking state

```scala
sealed trait Command[Before, After]

object Command {
  case class  Face(dir: Direction) extends Command[Idle, Idle]
  case object Start                extends Command[Idle, Moving]
  case object `Stop`                 extends Command

  case class Chain(
    cmd1: Command,
    cmd2: Command
  ) extends Command
}
```

---

## Tracking state

.diff-add[
```scala
sealed trait Command[Before, After]

object Command {
  case class  Face(dir: Direction) extends Command[Idle, Idle]
  case object Start                extends Command[Idle, Moving]
* case object Stop                 extends Command`[Moving, Idle]`

  case class Chain(
    cmd1: Command,
    cmd2: Command
  ) extends Command
}
```
]

---

## Tracking state

```scala
sealed trait Command[Before, After]

object Command {
  case class  Face(dir: Direction) extends Command[Idle, Idle]
  case object Start                extends Command[Idle, Moving]
  case object Stop                 extends Command[Moving, Idle]

* case class Chain(
*   cmd1: Command,
*   cmd2: Command
* ) extends Command
}
```

---

## Tracking state

.diff-add[
```scala
sealed trait Command[Before, After]

object Command {
  case class  Face(dir: Direction) extends Command[Idle, Idle]
  case object Start                extends Command[Idle, Moving]
  case object Stop                 extends Command[Moving, Idle]

  case class Chain(
*   cmd1: Command`[A, B]`,
    cmd2: Command
  ) extends Command
}
```
]

---

## Tracking state

.diff-add[
```scala
sealed trait Command[Before, After]

object Command {
  case class  Face(dir: Direction) extends Command[Idle, Idle]
  case object Start                extends Command[Idle, Moving]
  case object Stop                 extends Command[Moving, Idle]

  case class Chain(
    cmd1: Command[A, B],
*   cmd2: Command`[B, C]`
  ) extends Command
}
```
]

---

## Tracking state

```scala
sealed trait Command[Before, After]

object Command {
  case class  Face(dir: Direction) extends Command[Idle, Idle]
  case object Start                extends Command[Idle, Moving]
  case object Stop                 extends Command[Moving, Idle]

  case class Chain(
    cmd1: Command[A, `B`],
    cmd2: Command[`B`, C]
  ) extends Command
}
```

---

## Tracking state

.diff-add[
```scala
sealed trait Command[Before, After]

object Command {
  case class  Face(dir: Direction) extends Command[Idle, Idle]
  case object Start                extends Command[Idle, Moving]
  case object Stop                 extends Command[Moving, Idle]

  case class Chain(
    cmd1: Command[A, B],
    cmd2: Command[B, C]
* ) extends Command`[A, C]`
}
```
]

---

## Tracking state

.diff-add[
```scala
sealed trait Command[Before, After]

object Command {
  case class  Face(dir: Direction) extends Command[Idle, Idle]
  case object Start                extends Command[Idle, Moving]
  case object Stop                 extends Command[Moving, Idle]

* case class Chain`[A, B, C]`(
    cmd1: Command[A, B],
    cmd2: Command[B, C]
  ) extends Command[A, C]
}
```
]

---

## Tracking state

```scala
sealed trait Command[Before, After]

object Command {
  case class  Face(dir: Direction) extends Command[Idle, Idle]
  case object Start                extends Command[Idle, Moving]
  case object Stop                 extends Command[Moving, Idle]

  case class Chain[A, B, C](
    cmd1: Command[A, B],
    cmd2: Command[B, C]
  ) extends Command[A, C]
}
```

---

## DSL

```scala
implicit class Compose(cmd1: Command) {
  def ~>(cmd2: Command): Command =
    Command.Chain(cmd1, cmd2)
}
```

---

## DSL

.diff-add[
```scala
*implicit class Compose(cmd1: Command`[A, B]`) {
  def ~>(cmd2: Command): Command =
    Command.Chain(cmd1, cmd2)
}
```
]

---

## DSL

.diff-add[
```scala
*implicit class Compose`[A, B]`(cmd1: Command[A, B]) {
  def ~>(cmd2: Command): Command =
    Command.Chain(cmd1, cmd2)
}
```
]

---

## DSL

.diff-add[
```scala
implicit class Compose[A, B](cmd1: Command[A, B]) {
* def ~>(cmd2: Command`[B, C]`): Command =
    Command.Chain(cmd1, cmd2)
}
```
]

---

## DSL

.diff-add[
```scala
implicit class Compose[A, B](cmd1: Command[A, B]) {
* def ~>[`C`](cmd2: Command[B, C]): Command =
    Command.Chain(cmd1, cmd2)
}
```
]

---

## DSL

.diff-add[
```scala
implicit class Compose[A, B](cmd1: Command[A, B]) {
* def ~>[C](cmd2: Command[B, C]): Command`[A, C]` =
    Command.Chain(cmd1, cmd2)
}
```
]

---

## DSL

```scala
implicit class Compose[A, B](cmd1: Command[A, B]) {
  def ~>[C](cmd2: Command[B, C]): Command[A, C] =
    Command.Chain(cmd1, cmd2)
}
```




---

## Illegal state transition

![Start](img/valid-command-east-sending.png)

```scala
start ~> start
```

---

## Illegal state transition

![Start ](img/valid-command-rejected.png)

```scala
start ~> start
//        start ~> start
//                 ^
// On line 2: error: type mismatch;
//         found   : Command.Start.type
//         required: Command[Moving,?]
```

---

## Illegal state transition

![Start](img/valid-command-east-sending.png)

```scala
stop ~> stop
```

---

## Illegal state transition

![Start](img/valid-command-rejected.png)

```scala
stop ~> stop
//        stop ~> stop
//                ^
// On line 2: error: type mismatch;
//         found   : Command.Stop.type
//         required: Command[Idle,?]
```

---

## Illegal state transition

![Start](img/valid-command-east-sending.png)

```scala
start ~> face(north)
```

---

## Illegal state transition

![Start](img/valid-command-rejected.png)

```scala
start ~> face(north)
//        start ~> face(north)
//                     ^
// On line 2: error: type mismatch;
//         found   : Command.Face
//         required: Command[Moving,?]
```

---

## Safe state transition

![Start](img/valid-command-south.png)

```scala
 face(east) ~> start ~> stop
```

---

## Safe state transition

![Start](img/valid-command-south-sending.png)

```scala
 face(east) ~> start ~> stop
```

---

## Safe state transition

![Start](img/valid-command-east.png)

```scala
 `face(east)` ~> start ~> stop
```

---

## Safe state transition

![Start](img/valid-command-start.png)

```scala
 face(east) ~> `start` ~> stop
```

---

## Safe state transition

![Start](img/valid-command-stop.png)

```scala
 face(east) ~> start ~> `stop`
```

---

## Smarter exhaustivity checks

```scala
def movingLabel(cmd: Command[Moving, _]): String =
  cmd match {
    case Command.Stop              => "stop"
    case _: Command.Chain[_, _, _] => "chain"
  }
```

---

## Smarter exhaustivity checks

```scala
def movingLabel(cmd: `Command[Moving, _]`): String =
  cmd match {
    case Command.Stop              => "stop"
    case _: Command.Chain[_, _, _] => "chain"
  }
```

---

## Smarter exhaustivity checks

```scala
def movingLabel(cmd: Command[Moving, _]): String =
  cmd match {
    case `Command.Stop`              => "stop"
    case _: Command.Chain[_, _, _] => "chain"
  }
```

---

## Smarter exhaustivity checks

```scala
def movingLabel(cmd: Command[Moving, _]): String =
  cmd match {
    case Command.Stop              => "stop"
    case _: `Command.Chain[_, _, _]` => "chain"
  }
```

---

## Smarter exhaustivity checks

![Start](img/valid-command-east-sending.png)

```scala
movingLabel(Command.Start)
```

---

## Smarter exhaustivity checks

![Start](img/valid-command-rejected.png)

```scala
movingLabel(Command.Start)
//        movingLabel(Command.Start)
//                            ^
// On line 2: error: type mismatch;
//         found   : Command.Start.type
//         required: Command[Moving, _]
```

---

## Smarter exhaustivity checks

```scala
def movingLabel(cmd: Command[Moving, _]): String =
  cmd match {
    case Command.Stop              => "stop"
    case _: Command.Chain[_, _, _] => "chain"
  }
```

---

## Smarter exhaustivity checks

.diff-rm[
```scala
def movingLabel(cmd: Command[Moving, _]): String =
  cmd match {
    case Command.Stop              => "stop"
*   `case _: Command.Chain[_, _, _] => "chain"`
  }
```
]

---

## Smarter exhaustivity checks

.diff-add[
```scala
def movingLabel(cmd: Command[Moving, _]): String =
  cmd match {
    case Command.Stop              => "stop"
*&#x200B; `// case _: Command.Chain[_, _, _] => "chain"`
  }
```
]

---

## Smarter exhaustivity checks

```scala
def movingLabel(cmd: Command[Moving, _]): String =
  cmd match {
    case Command.Stop              => "stop"
 // case _: Command.Chain[_, _, _] => "chain"
  }
```


---

## Smarter exhaustivity checks

```scala
def movingLabel(cmd: Command[Moving, _]): String =
  cmd match {
    case Command.Stop              => "stop"
 // case _: Command.Chain[_, _, _] => "chain"
  }
//          cmd match {
//          ^
// On line 3: warning: match may not be exhaustive.
//        It would fail on the following input: Chain(_, _)
// error: No warnings can be incurred under -Werror.
```

---

## Smarter exhaustivity checks

.diff-rm[
```scala
def movingLabel(cmd: Command[Moving, _]): String =
  cmd match {
    case Command.Stop              => "stop"
*&#x200B; `// case _: Command.Chain[_, _, _] => "chain"`
  }
```
]

---

## Smarter exhaustivity checks

.diff-add[
```scala
def movingLabel(cmd: Command[Moving, _]): String =
  cmd match {
    case Command.Stop              => "stop"
*   `case _: Command.Chain[_, _, _] => "chain"`
  }
```
]

---

## Smarter exhaustivity checks

.diff-add[
```scala
def movingLabel(cmd: Command[Moving, _]): String =
  cmd match {
    case Command.Stop              => "stop"
    case _: Command.Chain[_, _, _] => "chain"
*   `case Command.Start             => "start"`
  }
```
]

---

## Smarter exhaustivity checks

```scala
def movingLabel(cmd: Command[Moving, _]): String =
  cmd match {
    case Command.Stop              => "stop"
    case _: Command.Chain[_, _, _] => "chain"
    case Command.Start             => "start"
  }
//            case Command.Start             => "start"
//                         ^
// On line 6: error: pattern type is incompatible with expected type;
//         found   : Command.Start.type
//         required: Command[Moving,_$1] where type _$1
```

---

## Type extraction

```scala
def movingLabel(cmd: Command[Moving, _]): String =
  cmd match {
    case Command.Stop              => "stop"
    case _: Command.Chain[t, _, _] =>
      implicitly[Moving =:= t]
      "chain"
  }
```

---

## Type extraction

```scala
def movingLabel(cmd: Command[Moving, _]): String =
  cmd match {
    case Command.Stop              => "stop"
    case _: `Command.Chain[t, _, _]` =>
      implicitly[Moving =:= t]
      "chain"
  }
```

---

## Type extraction

```scala
def movingLabel(cmd: Command[Moving, _]): String =
  cmd match {
    case Command.Stop              => "stop"
    case _: Command.Chain[`t`, _, _] =>
      implicitly[Moving =:= t]
      "chain"
  }
```

---

## Type extraction

```scala
def movingLabel(cmd: Command[Moving, _]): String =
  cmd match {
    case Command.Stop              => "stop"
    case _: Command.Chain[t, _, _] =>
      `implicitly[Moving =:= t]`
      "chain"
  }
```

---

## Key takeaways

--

We used type constraints on our sum type's members to:

--

* make illegal state transitions impossible to represent.

--

* guarantee that our code handles all necessary cases.

--

* guarantee that our code handles *only* necessary cases.

---
class: center, middle

# Generalised Algebraic Data Types

---

## Sum type

```scala
sealed trait Command[Before, After]

object Command {
  case class  Face(dir: Direction) extends Command[Idle, Idle]
  case object Start                extends Command[Idle, Moving]
  case object Stop                 extends Command[Moving, Idle]

  case class Chain[A, B, C](
    cmd1: Command[A, B],
    cmd2: Command[B, C]
  ) extends Command[A, C]
}
```

---

## Sum type

```scala
&#x200B;`sealed trait Command`[Before, After]

object Command {
  case class  Face(dir: Direction) extends Command[Idle, Idle]
  case object Start                extends Command[Idle, Moving]
  case object Stop                 extends Command[Moving, Idle]

  case class Chain[A, B, C](
    cmd1: Command[A, B],
    cmd2: Command[B, C]
  ) extends Command[A, C]
}
```

---

## Sum type

```scala
sealed trait Command[Before, After]

object Command {
  case class  `Face`(dir: Direction) extends Command[Idle, Idle]
  case object `Start`                extends Command[Idle, Moving]
  case object `Stop`                 extends Command[Moving, Idle]

  case class `Chain`[A, B, C](
    cmd1: Command[A, B],
    cmd2: Command[B, C]
  ) extends Command[A, C]
}
```


---

## Sum type

> A GADT is a sum type [...]

---

## Witness type

```scala
sealed trait Command[`Before`, After]

object Command {
  case class  Face(dir: Direction) extends Command[`Idle`, Idle]
  case object Start                extends Command[`Idle`, Moving]
  case object Stop                 extends Command[`Moving`, Idle]

  case class Chain[A, B, C](
    cmd1: Command[A, B],
    cmd2: Command[B, C]
  ) extends Command[`A`, C]
}
```

---

## Witness type

```scala
sealed trait Command[Before, `After`]

object Command {
  case class  Face(dir: Direction) extends Command[Idle, `Idle`]
  case object Start                extends Command[Idle, `Moving`]
  case object Stop                 extends Command[Moving, `Idle`]

  case class Chain[A, B, C](
    cmd1: Command[A, B],
    cmd2: Command[B, C]
  ) extends Command[A, `C`]
}
```


---

## Witness type

> A witness type describes properties of a sum type's branches at the type level.


---

## GADT

> A GADT is a sum type with one or more witness types [...]

---

## Type equality

```scala
def movingLabel(cmd: Command[`Moving`, _]): String =
  cmd match {
    case Command.Stop              => "stop"
 // case _: Command.Chain[_, _, _] => "chain"
    case Command.Start             => "start"
  }
```

---

## Type equality

```scala
def movingLabel(cmd: Command[Moving, _]): String =
  cmd match {
    case Command.Stop              => "stop"
 `// case _: Command.Chain[_, _, _] => "chain"`
    case Command.Start             => "start"
  }
```

---

## Type equality

```scala
def movingLabel(cmd: Command[Moving, _]): String =
  cmd match {
    case Command.Stop              => "stop"
 // case _: Command.Chain[_, _, _] => "chain"
    `case Command.Start             => "start"`
  }
```

---

## Type equality

> Type equality is information available to the compiler about each witness type, allowing it to refine pattern matches.

---

## GADT

> A GADT is a sum type with one or more witness types, each equipped with a type equality.


---

## Sum type in Scala

```scala
sealed trait Option[A]
case class Some[A](value: A) extends Option[A]
case class None[A]() extends Option[A]
```

---

## Sum type in Scala

```scala
&#x200B;`sealed trait Option[A]`
case class Some[A](value: A) extends Option[A]
case class None[A]() extends Option[A]
```

---

## Sum type in Scala

```scala
sealed trait Option[A]
&#x200B;`case class Some[A](value: A) extends Option[A]`
case class None[A]() extends Option[A]
```

---

## Sum type in Scala

```scala
sealed trait Option[A]
case class Some[A](value: A) extends Option[A]
&#x200B;`case class None[A]() extends Option[A]`
```

---

## Sum type in Scala

```scala
sealed trait Option[A]
case class `Some`[A](value: A) extends Option[A]
case class `None`[A]() extends Option[A]
```

---

## Sum type in Scala

```scala
def safeGet[A](oa: Some[A]): A =
  oa match {
    case Some(a) => a
 // case None    => ???
  }
```

---

## Sum type in Scala

```scala
def safeGet[A](oa: `Some`[A]): A =
  oa match {
    case `Some`(a) => a
 // case None    => ???
  }
```

---

## Sum type in Scala

```scala
def safeGet[A](oa: `Some`[A]): A =
  oa match {
    case Some(a) => a
 // case `None`    => ???
  }
```


---

## Key takeaways

--

* GADTs are sum types with interesting properties for pattern matching.

--

* Scala is bad at helping us see that.

---
class: center, middle

# How about some Haskell?

---

## `Option` in Haskell

```haskell
data Option a = Some a
              | None
```

---

## `Option` in Haskell

```haskell
data `Option a` = Some a
              | None
```

---

## `Option` in Haskell

```haskell
data Option a = `Some a`
              | None
```

---

## `Option` in Haskell

```haskell
data Option a = Some a
              | `None`
```

---

## `Option` in Haskell

```haskell
safe_get :: ??? -> a
```

---

## `Option` with witness

```haskell
{-#LANGUAGE EmptyDataDecls #-}
module Option (Option, Empty, NonEmpty, some, none) where

data Empty
data NonEmpty

data Option phantom a = Some a
                      | None

some :: a -> Option NonEmpty a
some a = Some a

none :: Option Empty a
none = None
```

---

## `Option` with witness

```haskell
{-#LANGUAGE EmptyDataDecls #-}
module Option (Option, Empty, NonEmpty, some, none) where

data Empty
data NonEmpty

data `Option phantom a` = Some a
                      | None

some :: a -> Option NonEmpty a
some a = Some a

none :: Option Empty a
none = None
```

---

## `Option` with witness

```haskell
{-#LANGUAGE EmptyDataDecls #-}
module Option (Option, Empty, NonEmpty, some, none) where

*data Empty
*data NonEmpty

data Option phantom a = Some a
                      | None

some :: a -> Option NonEmpty a
some a = Some a

none :: Option Empty a
none = None
```

---

## `Option` with witness

```haskell
{-#LANGUAGE EmptyDataDecls #-}
module Option (Option, Empty, NonEmpty, some, none) where

data Empty
data NonEmpty

data Option phantom a = Some a
                      | None

*some :: a -> Option NonEmpty a
*some a = Some a

none :: Option Empty a
none = None
```

---

## `Option` with witness

```haskell
{-#LANGUAGE EmptyDataDecls #-}
module Option (Option, Empty, NonEmpty, some, none) where

data Empty
data NonEmpty

data Option phantom a = Some a
                      | None

some :: a -> Option NonEmpty a
some a = Some a

*none :: Option Empty a
*none = None
```
---

## `Option` with witness

```haskell
{-#LANGUAGE EmptyDataDecls #-}
module Option (`Option, Empty, NonEmpty, some, none`) where

data Empty
data NonEmpty

data Option phantom a = `Some` a
                      | `None`

some :: a -> Option NonEmpty a
some a = Some a

none :: Option Empty a
none = None
```

---

## `Option` with witness

```haskell
safe_get :: Option NonEmpty a -> a
safe_get (Some a) = a
safe_get None = error "this can't happen"
```

---

## `Option` with witness

```haskell
safe_get :: `Option NonEmpty a` -> a
safe_get (Some a) = a
safe_get None = error "this can't happen"
```

---

## `Option` with witness

```haskell
safe_get :: Option NonEmpty a -> a
&#x200B;`safe_get (Some a) = a`
safe_get None = error "this can't happen"
```

---

## `Option` with witness

```haskell
safe_get :: Option NonEmpty a -> a
safe_get (Some a) = a
&#x200B;`safe_get None = error "this can't happen"`
```

---

## `Option` as a GADT

```haskell
{-#LANGUAGE GADTs, EmptyDataDecls #-}

data Empty
data NonEmpty

data Option phantom a where
  Some :: a -> Option NonEmpty a
  None :: Option Empty a
```

---

## `Option` as a GADT

```haskell
{-#LANGUAGE GADTs, EmptyDataDecls #-}

data Empty
data NonEmpty

data `Option phantom a` where
  Some :: a -> Option NonEmpty a
  None :: Option Empty a
```

---

## `Option` as a GADT

```haskell
{-#LANGUAGE GADTs, EmptyDataDecls #-}

data Empty
data NonEmpty

data Option phantom a where
  `Some :: a -> Option NonEmpty a`
  None :: Option Empty a
```

---

## `Option` as a GADT

```haskell
{-#LANGUAGE GADTs, EmptyDataDecls #-}

data Empty
data NonEmpty

data Option phantom a where
  Some :: a -> Option NonEmpty a
  `None :: Option Empty a`
```

---

## `Option` as a GADT

```haskell
safe_get :: Option NonEmpty a -> a
safe_get (Some a) = a
--safe_get None = error "this can't happen"
```

---

## `Option` as a GADT

```haskell
safe_get :: Option NonEmpty a -> a
safe_get (Some a) = a
&#x200B;`--safe_get None = error "this can't happen"`
```

---

## `Option` as a GADT

```haskell
full_get :: a -> Option phantom a -> a
full_get zero opt = case opt of
    None     -> zero
    (Some _) -> safe_get opt
```

---

## `Option` as a GADT

```haskell
full_get :: a -> Option phantom a -> a
full_get zero opt = case `opt` of
    None     -> zero
    (Some _) -> safe_get opt
```

---

## `Option` as a GADT

```haskell
full_get :: a -> `Option phantom a` -> a
full_get zero opt = case opt of
    None     -> zero
    (Some _) -> safe_get opt
```

---

## `Option` as a GADT

```haskell
full_get :: a -> Option phantom a -> a
full_get zero opt = case opt of
    None     -> zero
    `(Some _) -> safe_get opt`
```

---

## `Option` as a GADT

```haskell
full_get :: a -> Option phantom a -> a
full_get zero opt = case opt of
    None     -> zero
    (Some _) -> `safe_get opt`
```

```haskell
safe_get :: Option NonEmpty a -> a
```

---

## Key takeaways

--

Haskell makes GADTs very clear:

--

* Sum types.

--

* Witness types.

--

* Type equality.

---

## What now?

- [Conclusion](#closing)
- [Algebra of Types](#algebra_of_types)


---
class: center, middle
name: algebra_of_types

# The algebra of types

---

## Cardinality

> The cardinality of type `A` is written \\(\\vert A \\vert\\) and is the number of values of type `A`.

---

## Cardinality

.center[![Nothing](img/nothing_novalue.svg)]

---

## Cardinality

.center[![Nothing](img/nothing.svg)]

--

\\(\vert Nothing \\vert = 0\\)

---

## Cardinality

.center[![Unit](img/unit_novalue.svg)]


---

## Cardinality

.center[![Unit](img/unit.svg)]

--

\\(\vert Unit \\vert = 1\\)

---

## Cardinality

.center[![Boolean](img/boolean_novalue.svg)]

---

## Cardinality

.center[![Boolean](img/boolean_true.svg)]

---

## Cardinality

.center[![Boolean](img/boolean.svg)]

--

\\(\vert Boolean \\vert = 2\\)

---

## Sum types

```scala
sealed trait Or[+A, +B]

object Or {
  case class Left[A](value: A) extends Or[A, Nothing]
  case class Right[B](value: B) extends Or[Nothing, B]
}
```

---

## Sum types

```scala
sealed trait `Or[+A, +B]`

object Or {
  case class Left[A](value: A) extends Or[A, Nothing]
  case class Right[B](value: B) extends Or[Nothing, B]
}
```

---

## Sum types

```scala
sealed trait Or[+A, +B]

object Or {
  case class `Left[A]`(value: A) extends Or[A, Nothing]
  case class Right[B](value: B) extends Or[Nothing, B]
}
```

---

## Sum types

```scala
sealed trait Or[+A, +B]

object Or {
  case class Left[A](`value: A`) extends Or[A, Nothing]
  case class Right[B](value: B) extends Or[Nothing, B]
}
```

---

## Sum types

```scala
sealed trait Or[+A, +B]

object Or {
  case class Left[A](value: A) extends Or[A, Nothing]
  case class `Right[B]`(value: B) extends Or[Nothing, B]
}
```

---

## Sum types

```scala
sealed trait Or[+A, +B]

object Or {
  case class Left[A](value: A) extends Or[A, Nothing]
  case class Right[B](`value: B`) extends Or[Nothing, B]
}
```

---

## Sum types

```scala
type IntOrString = Int Or String
```

---

## Sum types

```scala
type IntOrString = `Int Or String`
```

---

## Sum types

.center[![Or](img/or_novalue.svg)]

---

## Sum types

.center[![Or](img/or_left.svg)]

--

\\(\vert A \mathbin{Or} B \\vert = \vert A \vert \ldots\\)

---

## Sum types

.center[![Or](img/or.svg)]

\\(\vert A \mathbin{Or} B \\vert = \vert A \vert \ldots\\)

---

## Sum types

.center[![Or](img/or.svg)]

\\(\vert A \mathbin{Or} B \\vert = \vert A \vert + \vert B \vert \\)

---

## Type equivalence

> We'll say that types `A` and `B` are equivalent if they have the same cardinality, and write `A ~= B`.

---

## Sum types

.section[Algebra]

```scala
1 + 1 = 2
```

.section[Types]
```scala
Unit Or Unit ~= Boolean
```

---

## Sum types

.section[Algebra]

```scala
&#x200B;`1 + 1 = 2`
```

.section[Types]
```scala
Unit Or Unit ~= Boolean
```

---

## Sum types

.section[Algebra]

```scala
&#x200B;`1` + `1` = 2
```

.section[Types]
```scala
&#x200B;`Unit` Or `Unit` ~= Boolean
```

---

## Sum types

.section[Algebra]

```scala
1 + 1 = `2`
```

.section[Types]
```scala
Unit Or Unit ~= `Boolean`
```

---

## Sum types

.section[Algebra]

```scala
1 `+` 1 = 2
```

.section[Types]
```scala
Unit `Or` Unit ~= Boolean
```

---

## Sum types

.section[Algebra]

```scala
1 + 1 `=` 2
```

.section[Types]
```scala
Unit Or Unit `~=` Boolean
```

---

## Sum types

.section[Algebra]

```scala
1 + 1 = 2
```

.section[Types]
```scala
&#x200B;`Unit Or Unit ~= Boolean`
```


---

## Sum types

.center[![Unit Or Unit = Boolean](img/unit_or_unit_novalue.svg)]

---

## Sum types

.center[![Unit Or Unit = Boolean](img/unit_or_unit_left.svg)]

---

## Sum types

.center[![Unit Or Unit = Boolean](img/unit_or_unit_left_right.svg)]

---

## Sum types

.center[![Unit Or Unit = Boolean](img/unit_or_unit_left_right_true.svg)]

---

## Sum types

.center[![Unit Or Unit = Boolean](img/unit_or_unit_left_right_true_false.svg)]


---

## Sum types

.center[![Unit Or Unit = Boolean](img/unit_or_unit.svg)]

---

## Sum types associativity

.section[Algebra]

```scala
a + (b + c) = (a + b) + c
```

.section[Types]
```scala
A Or (B Or C) ~= (A Or B) Or C
```

---

## Sum types associativity

.section[Algebra]

```scala
&#x200B;`a + (b + c) = (a + b) + c`
```

.section[Types]
```scala
A Or (B Or C) ~= (A Or B) Or C
```

---

## Sum types associativity

.section[Algebra]

```scala
&#x200B;`a` + (b + c) = (`a` + b) + c
```

.section[Types]
```scala
&#x200B;`A` Or (B Or C) ~= (`A` Or B) Or C
```

---

## Sum types associativity

.section[Algebra]

```scala
a + (`b` + c) = (a + `b`) + c
```

.section[Types]
```scala
A Or (`B` Or C) ~= (A Or `B`) Or C
```

---

## Sum types associativity

.section[Algebra]

```scala
a + (b + `c`) = (a + b) + `c`
```

.section[Types]
```scala
A Or (B Or `C`) ~= (A Or B) Or `C`
```

---

## Sum types associativity

.section[Algebra]

```scala
a `+` (b `+` c) = (a `+` b) `+` c
```

.section[Types]
```scala
A `Or` (B `Or` C) ~= (A `Or` B) `Or` C
```

---

## Sum types associativity

.section[Algebra]

```scala
a + (b + c) `=` (a + b) + c
```

.section[Types]
```scala
A Or (B Or C) `~=` (A Or B) Or C
```

---

## Sum types associativity

.section[Algebra]

```scala
a + (b + c) = (a + b) + c
```

.section[Types]
```scala
&#x200B;`A Or (B Or C) ~= (A Or B) Or C`
```

---

## Sum types associativity

.center[![A Or B Or C](img/a_or_b_or_c_novalue.svg)]

---

## Sum types associativity

.center[![A Or B Or C](img/a_or_b_or_c_lefta.svg)]

---

## Sum types associativity

.center[![A Or B Or C](img/a_or_b_or_c_lefta_rightleftb.svg)]

---

## Sum types associativity

.center[![A Or B Or C](img/a_or_b_or_c_lefta_rightleftb_rightrightc.svg)]

---

## Sum types associativity

.center[![A Or B Or C](img/a_or_b_or_c_leftlefta.svg)]

---

## Sum types associativity

.center[![A Or B Or C](img/a_or_b_or_c_leftlefta_leftrightb.svg)]

---

## Sum types associativity

.center[![A Or B Or C](img/a_or_b_or_c_leftlefta_leftrightb_rightc.svg)]


---

## Sum types associativity

.center[![A Or B Or C](img/a_or_b_or_c.svg)]

---

## Sum types commutativity

.section[Algebra]

```scala
a + b = b + a
```

.section[Types]

```scala
A Or B ~= B Or A
```

---

## Sum types commutativity

.section[Algebra]

```scala
&#x200B;`a + b = b + a`
```

.section[Types]

```scala
A Or B ~= B Or A
```

---

## Sum types commutativity

.section[Algebra]

```scala
&#x200B;`a` + b = b + `a`
```

.section[Types]

```scala
&#x200B;`A` Or B ~= B Or `A`
```

---

## Sum types commutativity

.section[Algebra]

```scala
a + `b` = `b` + a
```

.section[Types]

```scala
A Or `B` ~= `B` Or A
```

---

## Sum types commutativity

.section[Algebra]

```scala
a `+` b = b `+` a
```

.section[Types]

```scala
A `Or` B ~= B `Or` A
```

---

## Sum types commutativity

.section[Algebra]

```scala
a + b `=` b + a
```

.section[Types]

```scala
A Or B `~=` B Or A
```

---

## Sum types commutativity

.section[Algebra]

```scala
a + b = b + a
```

.section[Types]

```scala
&#x200B;`A Or B ~= B Or A`
```

---

## Sum types commutativity

.center[![A Or B](img/a_or_b_novalue.svg)]

---

## Sum types commutativity

.center[![A Or B](img/a_or_b_lefta.svg)]

---

## Sum types commutativity

.center[![A Or B](img/a_or_b_lefta_rightb.svg)]

---

## Sum types commutativity

.center[![A Or B](img/a_or_b_righta.svg)]

---

## Sum types commutativity

.center[![A Or B](img/a_or_b_righta_leftb.svg)]


---

## Sum types commutativity

.center[![A Or B](img/a_or_b.svg)]

---

## Sum types neutral element

.section[Algebra]

```scala
a + 0 = a
```

.section[Types]

```scala
A Or Nothing ~= A
```

---

## Sum types neutral element

.section[Algebra]

```scala
&#x200B;`a + 0 = a`
```

.section[Types]

```scala
A Or Nothing ~= A
```

---

## Sum types neutral element

.section[Algebra]

```scala
&#x200B;`a` + 0 = `a`
```

.section[Types]

```scala
&#x200B;`A` Or Nothing ~= `A`
```

---

## Sum types neutral element

.section[Algebra]

```scala
a + `0` = a
```

.section[Types]

```scala
A Or `Nothing` ~= A
```

---

## Sum types neutral element

.section[Algebra]

```scala
a `+` 0 = a
```

.section[Types]

```scala
A `Or` Nothing ~= A
```

---

## Sum types neutral element

.section[Algebra]

```scala
a + 0 `=` a
```

.section[Types]

```scala
A Or Nothing `~=` A
```

---

## Sum types neutral element

.section[Algebra]

```scala
a + 0 = a
```

.section[Types]

```scala
&#x200B;`A Or Nothing ~= A`
```

---

## Sum types neutral element

.center[![A Or B](img/a_or_nothing_novalue.svg)]

---

## Sum types neutral element

.center[![A Or B](img/a_or_nothing_lefta.svg)]

---

## Sum types neutral element

.center[![A Or B](img/a_or_nothing_lefta_nothing.svg)]

---

## Sum types neutral element

.center[![A Or B](img/a_or_nothing_a.svg)]


---

## Sum types neutral element

.center[![A Or B](img/a_or_nothing.svg)]

---

## Product types

```scala
case class And[A, B](left: A, right: B)
```

---

## Product types

```scala
case class `And[A, B]`(left: A, right: B)
```

---

## Product types

```scala
case class And[A, B](`left: A`, right: B)
```

---

## Product types

```scala
case class And[A, B](left: A, `right: B`)
```


---

## Product types

```scala
type IntAndString = Int And String
```

---

## Product types

```scala
type IntAndString = `Int And String`
```

---

## Product types

.center[![And](img/and_novalue.svg)]

---

## Product types

.center[![And](img/and_a1.svg)]

--

\\(\vert A \mathbin{And} B \\vert = \vert B \vert \ldots\\)

---

## Product types

.center[![And](img/and_an.svg)]

\\(\vert A \mathbin{And} B \\vert = \vert B \vert \ldots\\)

---

## Product types

.center[![And](img/and.svg)]


\\(\vert A \mathbin{And} B \\vert = \vert B \vert \ldots\\)

---

## Product types

.center[![And](img/and.svg)]

\\(\vert A \mathbin{And} B \\vert = \vert A \vert \times \vert B \vert \\)

---

## Product types

.section[Algebra]

```scala
a + a = 2 * a
```

.section[Types]

```scala
A Or A ~= Boolean And A
```

---

## Product types

.center[![A Or A](img/a_or_a_novalue.svg)]

---

## Product types

.center[![A Or A](img/a_or_a_lefta.svg)]

---

## Product types

.center[![A Or A](img/a_or_a_lefta_righta.svg)]

---

## Product types

.center[![A Or A](img/a_or_a_false_a.svg)]

---

## Product types

.center[![A Or A](img/a_or_a_true_a.svg)]

---

## Product types

.center[![A Or A](img/a_or_a.svg)]

---

## Product types associativity

.section[Algebra]

```scala
(a * b) * c = a * (b * c)
```

.section[Types]

```scala
(And And B) And C ~= A And (B And C)
```

---

## Product types associativity

.center[![A And B And C](img/a_and_b_and_c_novalue.svg)]


---

## Product types associativity

.center[![A And B And C](img/a_and_b_and_c_anda.svg)]

---

## Product types associativity

.center[![A And B And C](img/a_and_b_and_c_andc.svg)]


---

## Product types associativity

.center[![A And B And C](img/a_and_b_and_c.svg)]

---

## Product types commutativity

.section[Algebra]
```scala
a * b = b * a
```

.section[Types]

```scala
A And B ~= B And A
```

---

## Product types commutativity

.center[![A And B](img/a_and_b_novalue.svg)]

---

## Product types commutativity

.center[![A And B](img/a_and_b_andab.svg)]

---

## Product types commutativity

.center[![A And B](img/a_and_b_andba.svg)]


---

## Product types commutativity

.center[![A And B](img/a_and_b.svg)]

---

## Product types neutral element

.section[Algebra]

```scala
a * 1 = a
```

.section[Types]

```scala
A And Unit ~= A
```

---

## Product types netural element

.center[![A And Unit](img/a_and_unit_novalue.svg)]

---

## Product types netural element

.center[![A And Unit](img/a_and_unit_andaunit.svg)]

---

## Product types netural element

.center[![A And Unit](img/a_and_unit_a.svg)]


---

## Product types netural element

.center[![A And Unit](img/a_and_unit.svg)]

---

## Recursive types

```scala
sealed trait List[A]

case class Nil[A]() extends List[A]

case class ::[A](
  head: A,
  tail: List[A]
) extends List[A]
```

---

## Recursive types

```scala
*sealed trait List[A]

case class Nil[A]() extends List[A]

case class ::[A](
  head: A,
  tail: List[A]
) extends List[A]
```

---

## Recursive types

```scala
sealed trait List[A]

*case class Nil[A]() extends List[A]

case class ::[A](
  head: A,
  tail: List[A]
) extends List[A]
```

---

## Recursive types

```scala
sealed trait List[A]

case class Nil[A]() extends List[A]

case `class ::`[A](
  head: A,
  tail: List[A]
) `extends List[A]`
```

---

## Recursive types

```scala
sealed trait List[A]

case class Nil[A]() extends List[A]

case class ::[A](
  `head: A`,
  tail: List[A]
) extends List[A]
```

---

## Recursive types

```scala
sealed trait List[A]

case class Nil[A]() extends List[A]

case class ::[A](
  head: A,
  `tail: List[A]`
) extends List[A]
```


---

## Recursive types

.fix2[
 Type                     | Cardinality
--------------------------|--------------
 `Nil`                    | \\(1\\)
]

---

## Recursive types

.fix2[
 Type                     | Cardinality
--------------------------|--------------
 `Nil`                    | \\(1\\)
 `A :: Nil`              | \\(\vert A \vert\\)
]

---

## Recursive types

.fix2[
 Type                     | Cardinality
--------------------------|--------------
 `Nil`                    | \\(1\\)
 `A :: Nil`              | \\(\vert A \vert\\)
 `A :: A :: Nil`        | \\(\vert A \vert^2\\)
]

---

## Recursive types

.fix2[
 Type                     | Cardinality
--------------------------|--------------
 `Nil`                    | \\(1\\)
 `A :: Nil`              | \\(\vert A \vert\\)
 `A :: A :: Nil`        | \\(\vert A \vert^2\\)
...                       | ...
 `List[A]` (of size `n`) | \\(\vert A \vert^n\\)
]

---

## Recursive types

\\(\\vert List[A]^n \\vert = \displaystyle\sum_{i = 0}^n \vert A \vert^i\\)

---

## Recursive types

\\(\\vert List[A]^n \\vert = \frac{\vert A \vert^{n + 1} - 1}{\vert A \vert - 1}\\)

--

 Type                     | Cardinality | Detail
--------------------------|-------------|--------------------
 \\(List[Boolean]^2)\\)   | \\(7\\)     | `Nil`, `Boolean :: Nil`, `Boolean :: Boolean :: Nil`

---

## Recursive types

\\(\\vert List[A]^n \\vert = \frac{\vert A \vert^{n + 1} - 1}{\vert A \vert - 1}\\)

 Type                     | Cardinality | Detail
--------------------------|-------------|--------------------
 \\(List[Boolean]^2)\\)   | \\(7\\)     | `Nil`, `Boolean :: Nil`, `Boolean :: Boolean :: Nil`
 \\(List[Boolean]^3)\\)   | \\(15\\)   | `Nil`, `Boolean :: Nil`, `Boolean :: Boolean :: Nil`, `Boolean :: Boolean :: Boolean :: Nil`

---

## Key takeaways

--

* ADTs have a deep connection to the algebra you know.

--

* you can use this connection to prove fun facts about types.

--

* you can also use it to pad talks and look clever.

---
class: center, middle
name: closing

# In closing

---

## If you only remember 1 slide...

--

* ADTs make data structures simpler and safer.

--

* So do GADTs, only more so.

--

* Thinking about data structures that way will have a lasting impact on the way you write code.

---

class: center, middle

# Questions?

Nicolas Rinaudo • [@NicolasRinaudo] • [Besedo]

[Besedo]:https://twitter.com/besedo_official
[@NicolasRinaudo]:https://twitter.com/NicolasRinaudo
    </textarea>
    <script src="js/remark.js" type="text/javascript"></script>
    <script src="js/katex.js"></script>
    <script src="js/auto-render.js"></script>
    <link rel="stylesheet" href="css/katex.css">

    <script type="text/javascript">
var renderMath = function() {
  renderMathInElement(document.body);
}
var slideshow = remark.create({
  highlightStyle: 'github',
  highlightSpans: true,
  highlightLines: true
}, renderMath);
    </script>
  </body>
</html>
