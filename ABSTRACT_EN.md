# Talk Abstract

Algebraic Data Types are a simple yet surprisingly powerful concept, and one that all developers should be comfortable with.

This talk intends to motivate them, explain some of the theory behind them, and tackle their generalised form, GADTs.

# Elevator pitch

Algebraic Data Types are a simple yet surprisingly powerful concept, and one that all developers should be comfortable with. They're the best tool we have for designing data types and data structures, and I'd argue they're the only *reasonable* one we have.

In this talk, I'll try to convince you of that by showing you how bad things get when you try other approaches. We'll also tackle their generalised form (GADTs) and see what additional benefits they bring to the table.

# Talk Description

Algebraic Data Types are a very simple, yet very powerful tool to use when designing systems. Most developers are familiar with them, or subsets of what we call ADTs, even if they are not aware of them - enumerations, for example, or records.

The purpose of this talk is to clarify what ADTs are, what properties they have and how these properties can be used to express strong invariants at the data level - such as making illegal states or state transitions impossible to represent.

It also explores the generalised form of ADTs - GADTs - and attempts to lift some of the confusion that surrounds them in the Scala community.

We will also (lightly) tackle the theory behind them and try to understand where the “algebraic” part of the name comes from.

By the end of the talk, attendants should have a solid intuition of when and how to use them, and be able to bring them to use in their own projects directly.

# Misc.

ADTs are one of the techniques I find myself teaching most newcomers to functional programming - it’s a simple and elegant concept, but one that is not commonly taught or used in more, let’s say, down to earth communities.

Having both failed and succeeded at explaining them a fair amount of times, I feel I now have a fairly solid and intuitive explanation, working from concepts most developers are familiar with and enriching them little by little as new problems are found. I might not be the best person to speak on this subject, but I’ve done it enough that I certainly feel qualified to.
